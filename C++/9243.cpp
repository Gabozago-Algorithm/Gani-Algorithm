// [9243] 파일 완전 삭제

/*
어느 날, 상근이의 여자친구는 상근이에게 매우 긴급한 목소리로 전화했다.
"상근아, 나 급하게 지워야 될 파일이 있어! 이 파일은 절대 복구되면 안돼."

파일을 완전 삭제하려면 하드드라이브에서 그 구간을 새로운 데이터로 반복해서 덮어써야 한다.
상근이는 여자친구를 위해 파일 완전 삭제 프로그램을 만들려고 한다. 

사용자는 삭제할 파일을 하나 고르고, 몇 번 덮어씌울지 n을 입력한다.
n은 1부터 20까지 숫자 중 하나를 골라야 한다. 
상근이의 프로그램은 파일을 비트단위로 덮어씌운다.
한 번 덮어씌울 때, 0인 비트는 1로, 1인 비트는 0으로 덮어씌운다.

상근이는 프로그램을 완성했고 테스트해보려고 한다.
파일을 삭제하기 전에 파일이 있었던 곳의 비트와 
파일을 삭제한 후에 파일이 있었던 곳의 비트가 주어졌을 때, 
프로그램을 올바르게 작성했는지 출력한다.

이 문제에서 파일이 실제로 삭제되었는지는 중요한 것은 아니다.
상근이가 프로그램을 작성했으면 삭제가 성공한 것으로, 그 외의 경우는 모두 실패한 것

입력
첫째 줄에 N이 주어진다.(1 ≤ N ≤ 20) 
둘째 줄에는 파일을 삭제하기 전에 파일이 있었던 곳의 비트가 주어지고,
셋째 줄에는 삭제한 후에 비트가 주어진다.
비트는 0과 1로만 이루어져 있고, 두 문자열의 길이는 같다. 
비트는 최대 1000개의 문자로 이루어져 있다.

출력
첫째 줄에 삭제가 성공했으면 "Deletion succeeded"을, 
실패했으면 "Deletion failed"을 출력한다.
*/

#define _CRT_SECURE_NO_WARNINGS
// 표준 스트림에서 읽기 및 쓰기를 제어하는 개체를 선언
#include <iostream>
#include <algorithm>
#include <string>
using namespace std;

int main()
{
	int n;
	cin >> n;

	string a, b;
	cin >> a >> b;

	if (n % 2 == 0) {
		for (int i = 0; i < a.size(); i++) {
			// 비트가 같아야함
			if (a[i] != b[i]) {
				cout << "Deletion failed" << '\n';
				return 0;
			}
		}
		cout << "Deletion succeeded" << '\n';
	}
	else {
		for (int i = 0; i < a.size(); i++) {
			// 비트가 반대여야함
			if (a[i] == b[i]) {
				cout << "Deletion failed" << '\n';
				return 0;
			}
		}
		cout << "Deletion succeeded" << '\n';
	}
}